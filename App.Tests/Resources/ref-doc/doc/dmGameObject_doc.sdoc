elements {
  type: FUNCTION
  name: "ComponentIterProperties"
  brief: "Callback when iterating over the properties for a ..."
  description: "Callback when iterating over the properties for a component."
  parameters {
    name: "pit"
    doc: "the property iterator"
    types: "dmGameObject::SceneNodePropertyIterator"
  }
  parameters {
    name: "node"
    doc: "the scene node"
    types: "dmGameObject::SceneNode*"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeGetTypeIndex"
  brief: "Get the component type index. Used for with e.g. d..."
  description: "Get the component type index. Used for with e.g. dmGameObject::GetWorld()/GetContext()"
  returnvalues {
    name: "type_index"
    doc: "The type index."
    types: "uint32_t"
  }
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetNewWorldFn"
  brief: "set the new world callback"
  description: "Set the new world callback. Called when a collection (i.e. a \"world\") is created."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentNewWorld"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetDeleteWorldFn"
  brief: "set the world destroy callback"
  description: "Set the world destroy callback. Called when a collection (i.e. a \"world\") is destroyed."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentDeleteWorld"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetCreateFn"
  brief: "set the component create callback"
  description: "Set the component create callback. Called when a component instance is created."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentCreate"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetDestroyFn"
  brief: "set the component destroy callback"
  description: "Set the component destroy callback. Called when a component instance is destroyed."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentDestroy"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetInitFn"
  brief: "set the component init callback"
  description: "Set the component init callback. Called on each gameobject\'s components, during a gameobject\'s initialization."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentInit"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetFinalFn"
  brief: "set the component finalize callback"
  description: "Set the component finalize callback. Called on each gameobject\'s components, during a gameobject\'s finalization."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentFinal"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetAddToUpdateFn"
  brief: "set the component add-to-update callback"
  description: "Set the component add-to-update callback. Called for each component instal, when the game object is spawned."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentAddToUpdate"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetGetFn"
  brief: "set the component get callback"
  description: "Set the component get callback. Called when the scripts want to retrieve the individual component user data given an url."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentGet"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetRenderFn"
  brief: "set the component render callback"
  description: "Set the component render callback. Called when it\'s time to render all component instances."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentsRender"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetUpdateFn"
  brief: "set the component update callback"
  description: "Set the component update callback. Called when it\'s time to update all component instances."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentsUpdate"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetFixedUpdateFn"
  brief: "set the component update callback"
  description: "Set the component update callback. Called when it\'s time to update all component instances."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentsFixedUpdate"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetPostUpdateFn"
  brief: "set the component post update callback"
  description: "Set the component post update callback. Called for each collection after the update, before the render."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentsPostUpdate"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetOnMessageFn"
  brief: "set the component on-message callback"
  description: "Set the component on-message callback. Called multiple times per frame, to flush messages."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentOnMessage"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetOnInputFn"
  brief: "set the component on-input callback"
  description: "Set the component on-input callback. Called once per frame, before the Update function."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentOnInput"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetOnReloadFn"
  brief: "set the component on-reload callback"
  description: "Set the component on-reload callback. Called when the resource of a component instance is reloaded."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentOnReload"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetSetPropertiesFn"
  brief: "set the component set properties callback"
  description: "Set the component set properties callback. Called when the component instance is being spwned."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentSetProperties"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetGetPropertyFn"
  brief: "set the component get property callback"
  description: "Set the component get property callback. Called when accessing a property via <code>go.get()</code>"
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentGetProperty"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetSetPropertyFn"
  brief: "set the component set property callback"
  description: "Set the component set property callback. Called when accessing a property via <code>go.set()</code>"
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "callback"
    types: "ComponentSetProperty"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetContext"
  brief: "set the component type global context"
  description: "Set the component type global context. Usually set when registering the component type."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "context"
    doc: "component type global context"
    types: "void*"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeGetContext"
  brief: "get the component type global context"
  description: "get the component type global context"
  returnvalues {
    name: "context"
    doc: "component type global context"
    types: "void*"
  }
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetReadsTransforms"
  brief: "set the component type transform dependency flag"
  description: "Set the component type transform dependency flag.\nIf this flag is set, it might trigger an dmGameObject::UpdateTransforms() (if there are dirty transforms)"
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "reads_transforms"
    doc: "transform dependency flag"
    types: "bool"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetPrio"
  brief: "set the component type prio order"
  description: "Set the component type prio order. Defines the update order of the component types."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "prio"
    doc: "prio order"
    types: "uint16_t"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetHasUserData"
  brief: "set the component type need for a per component instance user data"
  description: "Set the component type need for a per component instance user data. Defaults to true."
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "has_user_data"
    doc: "does each component instance need user data"
    types: "bool"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetChildIteratorFn"
  brief: "set the component child iterator function"
  description: "set the component child iterator function. Called during inspection"
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "child iterator function"
    types: "FIteratorChildren"
  }
}
elements {
  type: FUNCTION
  name: "ComponentTypeSetPropertyIteratorFn"
  brief: "set the component property iterator function"
  description: "set the component property iterator function. Called during inspection"
  parameters {
    name: "type"
    doc: "the type"
    types: "ComponentType*"
  }
  parameters {
    name: "fn"
    doc: "property iterator function"
    types: "FIteratorProperties"
  }
}
elements {
  type: STRUCT
  name: "ComponentTypeCreateCtx"
  brief: "Context used when registering a new component type"
  description: "Context used when registering a new component type"
  members {
    name: "m_Config"
    doc: "The config file"
    type: "dmConfigFile::HConfig"
  }
  members {
    name: "m_Factory"
    doc: "The resource factory"
    type: "dmResource::HFactory"
  }
  members {
    name: "m_Register"
    doc: "The game object registry"
    type: "dmGameObject::HRegister"
  }
  members {
    name: "m_Script"
    doc: "The shared script context"
    type: "dmScript::HContext"
  }
  members {
    name: "m_Contexts"
    doc: "Mappings between names and contextx"
    type: "dmHashTable64<void*>"
  }
}
elements {
  type: FUNCTION
  name: "INVALID_INSTANCE_POOL_INDEX"
  brief: "Value for an invalid instance index, this must be ..."
  description: "Value for an invalid instance index, this must be the same as defined in gamesys_ddf.proto for Create#index."
}
elements {
  type: TYPEDEF
  name: "HInstance"
  brief: "Gameobject instance handle"
  description: "Gameobject instance handle"
}
elements {
  type: TYPEDEF
  name: "HScript"
  brief: "Script handle"
  description: "Script handle"
}
elements {
  type: TYPEDEF
  name: "HScriptInstance"
  brief: "Script instance handle"
  description: "Script instance handle"
}
elements {
  type: TYPEDEF
  name: "HRegister"
  brief: "Collection register."
  description: "Collection register."
}
elements {
  type: TYPEDEF
  name: "HCollection"
  brief: "Gameobject collection handle"
  description: "Gameobject collection handle"
}
elements {
  type: TYPEDEF
  name: "HPrototype"
  brief: "Gameobject prototype handle"
  description: "Gameobject prototype handle"
}
elements {
  type: TYPEDEF
  name: "HProperties"
  brief: "Gameobject properties handle"
  description: "Gameobject properties handle"
}
elements {
  type: ENUM
  name: "Result"
  brief: "result enumeration"
  description: "Result enumeration."
  members {
    name: "dmGameObject::RESULT_OK"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_OUT_OF_RESOURCES"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_ALREADY_REGISTERED"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_IDENTIFIER_IN_USE"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_IDENTIFIER_ALREADY_SET"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_COMPONENT_NOT_FOUND"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_MAXIMUM_HIEARCHICAL_DEPTH"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_INVALID_OPERATION"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_RESOURCE_TYPE_NOT_FOUND"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_BUFFER_OVERFLOW"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::RESULT_UNKNOWN_ERROR"
    doc: ""
    type: ""
  }
}
elements {
  type: ENUM
  name: "PropertyType"
  brief: "property types"
  description: "Property types."
  members {
    name: "dmGameObject::PROPERTY_TYPE_NUMBER"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_TYPE_HASH"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_TYPE_URL"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_TYPE_VECTOR3"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_TYPE_VECTOR4"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_TYPE_QUAT"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_TYPE_BOOLEAN"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_TYPE_COUNT"
    doc: ""
    type: ""
  }
}
elements {
  type: ENUM
  name: "PropertyResult"
  brief: "property result"
  description: "Property result."
  members {
    name: "dmGameObject::PROPERTY_RESULT_OK"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_NOT_FOUND"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_INVALID_FORMAT"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_UNSUPPORTED_TYPE"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_TYPE_MISMATCH"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_COMP_NOT_FOUND"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_INVALID_INSTANCE"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_BUFFER_OVERFLOW"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_UNSUPPORTED_VALUE"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_UNSUPPORTED_OPERATION"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_RESOURCE_NOT_FOUND"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_INVALID_INDEX"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROPERTY_RESULT_INVALID_KEY"
    doc: ""
    type: ""
  }
}
elements {
  type: ENUM
  name: "Playback"
  brief: "Playback type enum"
  description: "Playback type enum"
}
elements {
  type: ENUM
  name: "CreateResult"
  brief: "Create result enum"
  description: "Create result enum."
  members {
    name: "dmGameObject::CREATE_RESULT_OK"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::CREATE_RESULT_UNKNOWN_ERROR"
    doc: ""
    type: ""
  }
}
elements {
  type: ENUM
  name: "UpdateResult"
  brief: "Update result enum"
  description: "Update result enum."
  members {
    name: "dmGameObject::UPDATE_RESULT_OK"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::UPDATE_RESULT_UNKNOWN_ERROR"
    doc: ""
    type: ""
  }
}
elements {
  type: ENUM
  name: "PropertyValueType"
  brief: "Type of property value"
  description: "Type of property value"
  members {
    name: "dmGameObject::PROP_VALUE_ARRAY"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::PROP_VALUE_HASHTABLE"
    doc: ""
    type: ""
  }
}
elements {
  type: STRUCT
  name: "PropertyOptions"
  brief: "Property Options"
  description: "Parameters variant that holds key or index for a propertys data structure."
  members {
    name: "m_Index"
    doc: "The index of the property to set, only applicable if property is array."
    type: "int32_t"
  }
  members {
    name: "m_Key"
    doc: "The key of the property to set, only applicable if property is hashtable."
    type: "dmhash_t"
  }
  members {
    name: "m_HasKey"
    doc: "A flag if structure contain m_Key value (it can\'t contain both)"
    type: "uint8_t"
  }
}
elements {
  type: STRUCT
  name: "PropertyVar"
  brief: "property variant"
  description: "Property variant that holds the data for a variable"
  members {
    name: "m_Type"
    doc: "property type"
    type: "dmGameObject::PropertyType"
  }
  members {
    name: "m_Number"
    doc: "A floating point value (union)"
    type: "double"
  }
  members {
    name: "m_Hash"
    doc: "A hash value (union)"
    type: "dmhash_t"
  }
  members {
    name: "m_Url"
    doc: "An URL value (union)"
    type: "const uin8_t*"
  }
  members {
    name: "m_V4"
    doc: "A vector4 value (union)"
    type: "float"
  }
  members {
    name: "m_Bool"
    doc: "A boolean value (union)"
    type: "bool"
  }
}
elements {
  type: STRUCT
  name: "PropertyDesc"
  brief: "Description of a property"
  description: "Description of a property.\nIf the property is externally mutable, m_ValuePtr points to the value and its length is m_ElementCount.\nm_Variant always reflects the value."
  members {
    name: "m_ElementIds"
    doc: "For composite properties (float arrays), these ids name each element"
    type: "dmhash_t"
  }
  members {
    name: "m_Variant"
    doc: "Variant holding the value"
    type: "PropertyVar"
  }
  members {
    name: "m_ValuePtr"
    doc: "Pointer to the value, only set for mutable values. The actual data type is described by the variant."
    type: "float*"
  }
  members {
    name: "m_ReadOnly"
    doc: "Determines whether we are permitted to write to this property."
    type: "bool"
  }
  members {
    name: "m_ValueType"
    doc: "Indicates type of the property."
    type: "uint8_t"
  }
}
elements {
  type: STRUCT
  name: "UpdateContext"
  brief: "Update context"
  description: "Update context"
  members {
    name: "m_TimeScale"
    doc: "the scaling factor what was applied on the dt (i.e. the collection update time scale)"
    type: "float"
  }
  members {
    name: "m_DT"
    doc: "the delta time elapsed since last frame (seconds)"
    type: "float"
  }
  members {
    name: "m_FixedUpdateFrequency"
    doc: "Number of of calls per second to the FixedUpdate of each component"
    type: "uint32_t"
  }
}
elements {
  type: STRUCT
  name: "InputAction"
  brief: "Container of input related information."
  description: "Container of input related information."
}
elements {
  type: ENUM
  name: "InputResult"
  brief: "Input result enum"
  description: "Input result enum"
  members {
    name: "INPUT_RESULT_IGNORED"
    doc: "= 0"
    type: ""
  }
  members {
    name: "INPUT_RESULT_CONSUMED"
    doc: "= 1"
    type: ""
  }
  members {
    name: "INPUT_RESULT_UNKNOWN_ERROR"
    doc: "= -1000"
    type: ""
  }
}
elements {
  type: FUNCTION
  name: "GetMessageSocket"
  brief: "Retrieve the message socket for the specified coll..."
  description: "Retrieve the message socket for the specified collection."
  returnvalues {
    name: "socket"
    doc: "The message socket of the specified collection"
    types: "dmMessage::HSocket"
  }
  parameters {
    name: "collection"
    doc: "Collection handle"
    types: "dmGameObject::HCollection"
  }
}
elements {
  type: FUNCTION
  name: "GetCollection"
  brief: "Retrieve a collection from the specified instance"
  description: "Retrieve a collection from the specified instance"
  returnvalues {
    name: "collection"
    doc: "The collection the specified instance belongs to"
    types: "dmGameObject::HInstance"
  }
  parameters {
    name: "instance"
    doc: "Game object instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "New"
  brief: "Create a new gameobject instance"
  description: "Create a new gameobject instance"
  returnvalues {
    name: "instance"
    doc: "New gameobject instance. NULL if any error occured"
    types: "dmGameObject::HInstance"
  }
  parameters {
    name: "collection"
    doc: "Gameobject collection"
    types: "dmGameObject::HCollection"
  }
  parameters {
    name: "prototype_name"
    doc: "|type: const char*] Prototype file name. May be 0."
    types: ""
  }
}
elements {
  type: FUNCTION
  name: "Delete"
  brief: "Delete gameobject instance"
  description: "Delete gameobject instance"
  parameters {
    name: "collection"
    doc: "Gameobject collection"
    types: "dmGameObject::HCollection"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
  parameters {
    name: "recursive"
    doc: "If true, delete child hierarchy recursively in child to parent order (leaf first)"
    types: "bool"
  }
}
elements {
  type: FUNCTION
  name: "ConstructInstanceId"
  brief: "Construct a hash of an instance id based on the in..."
  description: "Construct a hash of an instance id based on the index provided."
  returnvalues {
    name: "id"
    doc: "hash of the instance id constructed."
    types: "dmhash_t"
  }
  parameters {
    name: "index"
    doc: "The index to base the id off of."
    types: "uint32_t"
  }
}
elements {
  type: FUNCTION
  name: "AcquireInstanceIndex"
  brief: "Retrieve an instance index from the index pool for..."
  description: "Retrieve an instance index from the index pool for the collection."
  returnvalues {
    name: "instance"
    doc: "index from the index pool of collection."
    types: "uint32_t"
  }
  parameters {
    name: "collection"
    doc: "Collection from which to retrieve the instance index."
    types: "dmGameObject::HColleciton"
  }
}
elements {
  type: FUNCTION
  name: "AssignInstanceIndex"
  brief: "Assign an index to the instance, only if the insta..."
  description: "Assign an index to the instance, only if the instance is not null."
  parameters {
    name: "index"
    doc: "The index to assign."
    types: "uint32_t"
  }
  parameters {
    name: "instance"
    doc: "The instance that should be assigned the index."
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "GetIdentifier"
  brief: "Get instance identifier"
  description: "Get instance identifier"
  returnvalues {
    name: ""
    doc: "Identifier. dmGameObject::UNNAMED_IDENTIFIER if not set."
    types: "dmhash_t"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "SetIdentifier"
  brief: "Set instance identifier. Must be unique within the..."
  description: "Set instance identifier. Must be unique within the collection."
  returnvalues {
    name: "result"
    doc: "RESULT_OK on success"
    types: "dmGameObject::Result"
  }
  parameters {
    name: "collection"
    doc: "Collection"
    types: "dmGameObject::HCollection"
  }
  parameters {
    name: "instance"
    doc: "Instance"
    types: "dmGameObject::HInstance"
  }
  parameters {
    name: "identifier"
    doc: "Identifier"
    types: "dmhash_t"
  }
}
elements {
  type: FUNCTION
  name: "GetComponentId"
  brief: "Get component id from component index."
  description: "Get component id from component index."
  returnvalues {
    name: "result"
    doc: "RESULT_OK if the comopnent was found"
    types: "dmGameObject::Result"
  }
  parameters {
    name: "instance"
    doc: "Instance"
    types: "dmGameObject::HInstance"
  }
  parameters {
    name: "component_index"
    doc: "Component index"
    types: "uint16_t"
  }
  parameters {
    name: "component_id"
    doc: "[type: dmhash_t* Component id as out-argument"
    types: ""
  }
}
elements {
  type: FUNCTION
  name: "SetPosition"
  brief: "set position"
  description: "Set gameobject instance position"
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
  parameters {
    name: "position"
    doc: "New Position"
    types: "dmGameObject::Point3"
  }
}
elements {
  type: FUNCTION
  name: "GetPosition"
  brief: "get position"
  description: "Get gameobject instance position"
  returnvalues {
    name: ""
    doc: "Position"
    types: "dmGameObject::Point3"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "SetRotation"
  brief: "set rotation"
  description: "Set gameobject instance rotation"
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
  parameters {
    name: "position"
    doc: "New Position"
    types: ""
  }
}
elements {
  type: FUNCTION
  name: "GetRotation"
  brief: "get rotation"
  description: "Get gameobject instance rotation"
  returnvalues {
    name: ""
    doc: "rotation"
    types: "dmGameObject::Quat"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "SetScale"
  brief: "set uniform scale"
  description: "Set gameobject instance uniform scale"
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
  parameters {
    name: "scale"
    doc: "New uniform scale"
    types: ""
  }
}
elements {
  type: FUNCTION
  name: "SetScale"
  brief: "set scale"
  description: "Set gameobject instance non-uniform scale"
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
  parameters {
    name: "scale"
    doc: "New uniform scale"
    types: ""
  }
}
elements {
  type: FUNCTION
  name: "GetUniformScale"
  brief: "get uniform scale"
  description: "Get gameobject instance uniform scale"
  returnvalues {
    name: ""
    doc: "Uniform scale"
    types: "float"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "GetScale"
  brief: "get scale"
  description: "Get gameobject instance scale"
  returnvalues {
    name: ""
    doc: "Non-uniform scale"
    types: "dmGameObject::Vector3"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "GetWorldPosition"
  brief: "get world position"
  description: "Get gameobject instance world position"
  returnvalues {
    name: ""
    doc: "World position"
    types: "dmGameObject::Point3"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "GetWorldRotation"
  brief: "get world rotation"
  description: "Get gameobject instance world rotation"
  returnvalues {
    name: ""
    doc: "World rotation"
    types: "dmGameObject::Quat"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "GetWorldScale"
  brief: "get world scale"
  description: "Get game object instance world transform"
  returnvalues {
    name: ""
    doc: "World scale"
    types: "dmGameObject::Vector3"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "GetWorldUniformScale"
  brief: "get world uniform scale"
  description: "Get game object instance uniform scale"
  returnvalues {
    name: ""
    doc: "World uniform scale"
    types: "float"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "GetWorldMatrix"
  brief: "get world matrix"
  description: "Get game object instance world transform as Matrix4."
  returnvalues {
    name: ""
    doc: "World transform matrix."
    types: "dmGameObject::MAtrix4"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "GetWorldTransform"
  brief: "get world transform"
  description: "Get game object instance world transform"
  returnvalues {
    name: ""
    doc: "World transform"
    types: "dmTransform::Transform"
  }
  parameters {
    name: "instance"
    doc: "Gameobject instance"
    types: "dmGameObject::HInstance"
  }
}
elements {
  type: FUNCTION
  name: "SetBone"
  brief: "Set whether the instance should be flagged as a bo..."
  description: "Set whether the instance should be flagged as a bone.\nInstances flagged as bones can have their transforms updated in a batch through SetBoneTransforms.\nUsed for animated skeletons."
  parameters {
    name: "instance"
    doc: "Instance"
    types: "HImstance"
  }
  parameters {
    name: "bone"
    doc: "true if the instance is a bone"
    types: "bool"
  }
}
elements {
  type: FUNCTION
  name: "IsBone"
  brief: "Check whether the instance is flagged as a bone."
  description: "Check whether the instance is flagged as a bone."
  returnvalues {
    name: "result"
    doc: "True if flagged as a bone"
    types: "bool"
  }
  parameters {
    name: "instance"
    doc: "Instance"
    types: "HImstance"
  }
}
elements {
  type: FUNCTION
  name: "SetBoneTransforms"
  brief: "Set the local transforms recursively of all instan..."
  description: "Set the local transforms recursively of all instances flagged as bones, starting with component with id.\nThe order of the transforms is depth-first."
  returnvalues {
    name: "Number"
    doc: "of instances found"
    types: ""
  }
  parameters {
    name: "instance"
    doc: "First Instance of the hierarchy to set"
    types: "HImstance"
  }
  parameters {
    name: "component_transform"
    doc: "the transform for component root"
    types: "dmTransform::Transform"
  }
  parameters {
    name: "transforms"
    doc: "Array of transforms to set depth-first for the bone instances"
    types: ""
  }
  parameters {
    name: "transform_count"
    doc: "Size of the transforms array"
    types: ""
  }
}
elements {
  type: FUNCTION
  name: "DeleteBones"
  brief: "Recursively delete all instances flagged as bones ..."
  description: "Recursively delete all instances flagged as bones under the given parent instance.\nThe order of deletion is depth-first, so that the children are deleted before the parents."
  parameters {
    name: "parent"
    doc: "Parent instance of the hierarchy"
    types: "HInstance"
  }
}
elements {
  type: STRUCT
  name: "SceneNode"
  brief: "scene graph traversal node"
  description: "Opaque struct that holds info about the current node"
}
elements {
  type: STRUCT
  name: "SceneNodeIterator"
  brief: "scene graph traversal iterator"
  description: "Opaque struct that holds info about the current position when traversing the scene"
}
elements {
  type: FUNCTION
  name: "TraverseGetRoot"
  brief: "Gets the top node of the whole game (the main coll..."
  description: "Gets the top node of the whole game (the main collection)"
  returnvalues {
    name: "result"
    doc: "True if successful"
    types: "bool"
  }
  parameters {
    name: "regist"
    doc: "the full gameobject register"
    types: "dmGameObject::HRegister"
  }
  parameters {
    name: "node"
    doc: "the node to inspect"
    types: "dmGameObject::HRegister"
  }
  examples: "The following examples show how to iterate over currently loaded scene graph\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">OutputNode</span><span class=\"p\">(</span><span class=\"n\">dmGameObject</span><span class=\"o\">::</span><span class=\"n\">SceneNode</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">dmGameObject</span><span class=\"o\">::</span><span class=\"n\">SceneNodeIterator</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dmGameObject</span><span class=\"o\">::</span><span class=\"n\">TraverseIterateChildren</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">dmGameObject</span><span class=\"o\">::</span><span class=\"n\">TraverseIterateNext</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">it</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">OutputProperties</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">it</span><span class=\"p\">.</span><span class=\"n\">m_Node</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// see dmGameObject::TraverseIterateProperties()</span>\n<span class=\"w\">        </span><span class=\"n\">OutputNode</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">it</span><span class=\"p\">.</span><span class=\"n\">m_Node</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"nf\">OutputScene</span><span class=\"p\">(</span><span class=\"n\">HRegister</span><span class=\"w\"> </span><span class=\"n\">regist</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">dmGameObject</span><span class=\"o\">::</span><span class=\"n\">SceneNode</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">dmGameObject</span><span class=\"o\">::</span><span class=\"n\">TraverseGetRoot</span><span class=\"p\">(</span><span class=\"n\">regist</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">root</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">false</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">OutputNode</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">node</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>"
}
elements {
  type: FUNCTION
  name: "TraverseIterateChildren"
  brief: "Get a scene node iterator for the nodes\' children"
  description: "Get a scene node iterator for the nodes\' children"
  returnvalues {
    name: "iterator"
    doc: "the iterator"
    types: "dmGameObject::SceneNodeIterator"
  }
  parameters {
    name: "node"
    doc: "the parent node"
    types: "dmGameObject::SceneNode*"
  }
}
elements {
  type: FUNCTION
  name: "TraverseIterateNext"
  brief: "Step a scene node iterator to the next sibling"
  description: "Step a scene node iterator to the next sibling"
  returnvalues {
    name: "result"
    doc: "true if successful. false if the iterator is finished"
    types: "bool"
  }
  parameters {
    name: "it"
    doc: "the iterator"
    types: "dmGameObject::SceneNodeIterator*"
  }
}
elements {
  type: ENUM
  name: "SceneNodePropertyType"
  brief: "scene node property types"
  description: "scene node property types"
  members {
    name: "dmGameObject::SCENE_NODE_PROPERTY_TYPE_NUMBER"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::SCENE_NODE_PROPERTY_TYPE_HASH"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::SCENE_NODE_PROPERTY_TYPE_URL"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::SCENE_NODE_PROPERTY_TYPE_VECTOR3"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::SCENE_NODE_PROPERTY_TYPE_VECTOR4"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::SCENE_NODE_PROPERTY_TYPE_QUAT"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::SCENE_NODE_PROPERTY_TYPE_BOOLEAN"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::SCENE_NODE_PROPERTY_TYPE_TEXT"
    doc: ""
    type: ""
  }
  members {
    name: "dmGameObject::SCENE_NODE_PROPERTY_TYPE_COUNT"
    doc: ""
    type: ""
  }
}
elements {
  type: STRUCT
  name: "SceneNodeProperty"
  brief: "scene traversal node property"
  description: "Struct that holds info about the current position when traversing the scene"
  members {
    name: "m_NameHash"
    doc: "name"
    type: "dmhash_t"
  }
  members {
    name: "m_Type"
    doc: "type"
    type: "dmGameObject::SceneNodePropertyType"
  }
  members {
    name: "m_Value"
    doc: "value\n<dl>\n<dt><code>m_Number</code></dt>\n<dd><span class=\"type\">double</span> floating point number</dd>\n<dt><code>m_Hash</code></dt>\n<dd><span class=\"type\">dmhash_t</span> The hashed value.</dd>\n<dt><code>m_URL</code></dt>\n<dd><span class=\"type\">char[1024</span>] The text representation of the url (if reverse hashes are enabled)</dd>\n<dt><code>m_V4</code></dt>\n<dd><span class=\"type\">float[4</span>] Used for Vector3, Vector4 and Quat</dd>\n<dt><code>m_Bool</code></dt>\n<dd><span class=\"type\">bool</span> A boolean value</dd>\n<dt><code>m_Text</code></dt>\n<dd><span class=\"type\">const char*</span> Text from a text property</dd>\n</dl>"
    type: "union"
  }
}
elements {
  type: STRUCT
  name: "SceneNodePropertyIterator"
  brief: "scene traversal node property"
  description: "Holds the property"
  members {
    name: "m_Property"
    doc: "property"
    type: "dmGameObject::SceneNodeProperty"
  }
}
elements {
  type: FUNCTION
  name: "TraverseIterateProperties"
  brief: "Create a scene node traversal property iterator"
  description: "Create a scene node traversal property iterator"
  returnvalues {
    name: "iterator"
    doc: "the property iterator"
    types: "dmGameObject::SceneNodePropertyIterator"
  }
  parameters {
    name: "node"
    doc: "the node to inspect"
    types: "dmGameObject::SceneNode*"
  }
  examples: "The following examples show how to iterate over the properties of a node\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">dmGameObject</span><span class=\"o\">::</span><span class=\"n\">SceneNodePropertyIterator</span><span class=\"w\"> </span><span class=\"n\">pit</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">TraverseIterateProperties</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">dmGameObject</span><span class=\"o\">::</span><span class=\"n\">TraverseIteratePropertiesNext</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pit</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dmHashReverseSafe64</span><span class=\"p\">(</span><span class=\"n\">pit</span><span class=\"p\">.</span><span class=\"n\">m_Property</span><span class=\"p\">.</span><span class=\"n\">m_NameHash</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">switch</span><span class=\"p\">(</span><span class=\"n\">pit</span><span class=\"p\">.</span><span class=\"n\">m_Property</span><span class=\"p\">.</span><span class=\"n\">m_Type</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">dmGameObject</span><span class=\"o\">::</span><span class=\"no\">SCENE_NODE_PROPERTY_TYPE_NUMBER</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">...</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>"
}
elements {
  type: FUNCTION
  name: "TraverseIteratePropertiesNext"
  brief: "Steps the scene node traversal property iterator t..."
  description: "Steps the scene node traversal property iterator to the next property"
  returnvalues {
    name: "finished"
    doc: "True if the iterator it valid, false if the iterator is finished."
    types: "bool"
  }
  parameters {
    name: "it"
    doc: "the iterator"
    types: "dmGameObject::SceneNodePropertyIterator*"
  }
}
elements {
  type: FUNCTION
  name: "GetComponentFromLua"
  brief: "Get component user data from a url"
  description: "Get component user data from a url.\nThe object referenced by the url must be in the same collection as the caller."
  parameters {
    name: "L"
    doc: "Lua state"
    types: "lua_State*"
  }
  parameters {
    name: "index"
    doc: "index to argument (a url)"
    types: "lua_State*"
  }
  parameters {
    name: "component_type"
    doc: "the call will fail if the found component does not have the specified extension"
    types: "const char*"
  }
  parameters {
    name: "world"
    doc: "The world associated owning the component. May be 0"
    types: "void**"
  }
  parameters {
    name: "component"
    doc: "The component data associated with the url. May be 0"
    types: "void**"
  }
  parameters {
    name: "url"
    doc: "The resolved url. May be 0"
    types: "dmMessage::URL*"
  }
}
elements {
  type: FUNCTION
  name: "dmScript::PostDDF"
  brief: "Sends a script message"
  description: "Sends a script message. Wraps the message in a dmGameSystemDDF::ScriptMessage struct."
  returnvalues {
    name: "success"
    doc: "true if successful"
    types: "bool"
  }
  parameters {
    name: "message"
    doc: "The ddf message to send"
    types: "TDDFType*"
  }
  parameters {
    name: "sender"
    doc: "The sender"
    types: "dmMessage::Message*"
  }
  parameters {
    name: "receiver"
    doc: "The receiver"
    types: "dmMessage::Message*"
  }
  parameters {
    name: "function_ref"
    doc: "The function ref. 0 wil cause the \"on_message\" to be called"
    types: "int"
  }
  parameters {
    name: "unref_function_after_call"
    doc: "call dmScript::UnrefInInstance on the function_ref after the dmScript::PCall is made"
    types: "bool"
  }
}
info {
  namespace: "dmGameObject"
  name: "Script"
  brief: "SDK GameObject script API documentation"
  description: "<span class=\"file\"><dmsdk/gameobject/script.h></span>"
  path: ""
  file: ""
}
